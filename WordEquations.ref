/*
    Главный модуль обработки уравнений.
   Здесь проводится расщепление уравнений на простейшие и вызов специальных алгоритмов для работы с уравнениями ограниченных классов.
   
   [PRTCEquation] ::= (AreEqual (s.Log)(e.PRTCExpr)(e.PRTCExpr))
   [WordEquation] ::= (AreEqual (s.Log)([MultiSet])(e.WevalExpr)([MultiSet])(e.WevalExpr))
   
   PRTCExpr содержит параметры, вызовы функций, переменные образца.
   WevalExpr содержит только переменные weval.
   
   Экспортируемые функции:
   ParametrizeExpression --- функции превращения уравнения из PRTCEquation в WordEquation.
   
   IterateProcessQWEs --- функция вызова обработки квадратичных уравнений.
   ([WordEquation]^*)^* => ({[WordEquation]^*|Zero})^*
   
   IterateWESimpleTransforms --- простейшая обработка уравнений (расщеплением).
   ([WordEquation]^*)^* => ({[WordEquation]^*|Zero})^*
*/

/* из модуля basics.ref */
$EXTERN TermContradiction, MaxElementPowerMS, IfIncluded,Substitute,LessGenericPattern,IsTerm,MSCPError,Map;
$EXTERN IfASubMultiSet, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,SubtractEl,InsertInMultiSet,MergeSets,SymSubstMS;
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, RenewIndices, FreshIndex, CurrentIndex,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из модуля Drive.ref */
$EXTERN SolveEquations,ShuffleMode;
/* из модуля DiofEqs.ref */
$EXTERN SolveLinearDE,NormalizeNumericEquation,GenerateLengthRestriction;
/* из модуля WordEqsCases.ref */
$EXTERN DecideQWESolvability;
/* из модуля accessMSCP.ref */
$EXTERN SubstituteInNumeric, AddEBVariants, ReplaceEBNumericEqs, ReplaceEBNewEqs, ReplaceEBGrammars, GetEBNewEqs, GetEBNumericEqs,
DeleteEBEquation, SubstituteEBAsgs, NormalizeEB, IsContradictory, AddEBNewEqs, MakeEBContr,GenerateNewEB, GetFirstVariants,
ReplaceEBGenEqs, GetEBGenEqs, AddEBGenEqs, GetEBState, DeleteDoubleEqs, AddEBNumEqs, PutEBState;
/* из модуля accessMSCP.ref */
$EXTERN GenerateFreshPRTC,ReplacePRTCNewEqs,AddPRTCGenericEqs,GetPRTCNewEqs, GetPRTCRestrs;

$EXTERN GenerateNewNode, UnfoldMain, RestartIndices, AssignTimeStamps, YieldDecomposition, FormatStack;
/*
*********************************************************************************************************************
   
   Функции перевода уравнения в терминах конфигурации в уравнение в словах.
   
*********************************************************************************************************************
*/


/*
    Параметризация выражения переменными рода weval вместо данных языка.
   [Expression] может содержать вызовы, параметры, переменные образца.
   [ParamExpression] ничего из этого не содержит.
   (([ParAssignments])([VarAssignments])([CallAssignments]))([ParamExpression])[Expression] => 
   (([ParAssignments])([VarAssignments])([CallAssignments]))([ParamExpression])
*/

$ENTRY ParametrizeExpression {
	s.Mode (e.ParameterList)(e.Parametrized)
		 = (e.ParameterList)(e.Parametrized);
	s.Mode (e.OldParameterList)(e.Parametrized)s.x e.NP
		 = <ParametrizeExpression s.Mode (e.OldParameterList)(e.Parametrized s.x) e.NP>;
/* 2. Сначала параметризуем выражение в скобках, затем - за ними, используя обновленный список строковых переменных. */
        s.Mode (e.OldParameterList)(e.Parametrized)('*'e.NP1) e.NP2,
            <ParametrizeExpression s.Mode (e.OldParameterList)()e.NP1> :(e.NewParameterList)(e.InBrackets)
                = <ParametrizeExpression s.Mode
                    (e.NewParameterList)
                    (e.Parametrized ('*'e.InBrackets))
                    e.NP2
                >;
	s.Mode (e.OldParameterList)(e.Parametrized)(weval e.wvdata) e.NP
		 = <ParametrizeExpression s.Mode
			(e.OldParameterList)(e.Parametrized (weval e.wvdata)) e.NP>;		
	s.Mode (e.OldParList)(e.Parametrized)t.ToParameter e.NP,
        e.OldParList : e.1 (e.OldParList1 (assign t.ToParameter (t.weval)) e.OldParList2) e.2 
		 = <ParametrizeExpression s.Mode
                        (e.OldParList)(e.Parametrized t.weval) e.NP
		>;		
	s.Mode (e.OldParList)(e.Parametrized)(t.sort s.type t.name) e.NP,
        <IndivIndex s.Mode <FreshIndex <Explode s.Mode><Explode s.type>'_ind'>> : t.index,
        (assign (t.sort s.type t.name)((s.Mode s.type t.index))) : t.newasg,
        e.OldParList : (e.ParAsgs)(e.VarAsgs)(e.CallAsgs),
        t.sort :
            {   par = <ParametrizeExpression s.Mode
                        ((e.ParAsgs t.newasg)(e.VarAsgs)(e.CallAsgs))
                        (e.Parametrized (s.Mode s.type t.index)) 
                        e.NP
                    >;
                var = <ParametrizeExpression s.Mode
                        ((e.ParAsgs)(e.VarAsgs t.newasg)(e.CallAsgs))
                        (e.Parametrized (s.Mode s.type t.index)) 
                        e.NP
                    >;
            };		
	s.Mode (e.OldParList)(e.Parametrized)(call e.call) e.NP,
        <IndivIndex s.Mode <FreshIndex <Explode s.Mode>'e_ind'>> : t.index,
        (assign (call e.call)((s.Mode e t.index))) : t.newasg,
        e.OldParList : (e.ParAsgs)(e.VarAsgs)(e.CallAsgs)        
            = <ParametrizeExpression s.Mode
                        ((e.ParAsgs)(e.VarAsgs)(e.CallAsgs t.newasg))
                        (e.Parametrized (s.Mode e t.index)) 
                        e.NP
                    >;
}

IndivIndex {
    var t.index = <Implode 'Neg'<Symb t.index>>;
    weval t.index = t.index;
}

/*
    Функции, подготовительные для суперкомпиляции как алгоритма преобразования уравнений.
   Сейчас в MSCP не используются. 
*/

ExtractPseudoFunction {
    ((par e t.name) e.LHS)(e.RHS)(e.FPart1)(e.FPart2)(e.FPart3)(e.FPart4) =
        (e.FPart1 (par e t.name))<ExtractPseudoFunction ((par e t.name) e.LHS)(e.RHS)(e.FPart2)(e.FPart3)(e.FPart4)>;
    (e.LHS (par e t.name))(e.RHS)(e.FPart2)(e.FPart3)(e.FPart4) =
        ((par e t.name) e.FPart2)<ExtractPseudoFunction (e.RHS)(e.FPart3)(e.FPart4)>;
    ((par e t.name) e.RHS)(e.FPart3)(e.FPart4) =
        (e.FPart3 (par e t.name))<ExtractPseudoFunction ((weval e t.name) e.RHS)(e.FPart4)>;
    (e.RHS (weval e t.name))(e.FPart4) =
        ((weval e t.name) e.FPart4);
    (t.1 e.LHS)(e.RHS)(e.FPart1)(e.FPart2)(e.FPart3)(e.FPart4) =
        <ExtractPseudoFunction (e.LHS)(e.RHS)(e.FPart1 t.1)(e.FPart2)(e.FPart3)(e.FPart4)>;
    (t.1 e.RHS)(e.FPart3)(e.FPart4) =
        <ExtractPseudoFunction (e.RHS)(e.FPart3 t.1)(e.FPart4)>;
    (e.LHS t.1)(e.RHS)(e.FPart2)(e.FPart3)(e.FPart4) =
        <ExtractPseudoFunction (e.LHS)(e.RHS)(t.1 e.FPart2)(e.FPart3)(e.FPart4)>;
    (e.RHS t.1)(e.FPart4) =
        <ExtractPseudoFunction (e.RHS)(t.1 e.FPart4)>;
}

GeneratePattern {
    ((e.sort e t.par) e.LHS)(s.Sym e.RHS)
        = ((('*'s.Sym(var e x))('*'(var e y))(var t z)(var t z))(Restart))
        ((('*')('*'(var e y))(var t z)(var t z))(Restart));
    (s.Sym e.LHS)((e.sort e t.par) e.RHS) 
        = ((('*'(var e x))('*'s.Sym(var e y))(var t z)(var t z))(Restart))
        ((('*'(var e x))('*')(var t z)(var t z))(Restart));
    ((e.sort e t.par1) e.LHS)((e.sort e t.par2) e.RHS) 
        = ((('*'(var e x))('*'(var e x))(var t z)(var t z))(Restart))
        ((('*'(var e x))('*'(var e x)(var t w)(var e y))(var t z)(var t z))(Restart))
        ((('*'(var e y)(var t w)(var e x))('*'(var e y))(var t z)(var t z))(Restart));
}

GenerateNewParameters {
    (e.Pars) e.Expr1('*'e.Expr2) e.Expr3 = <GenerateNewParameters (e.Pars)e.Expr1 e.Expr2 e.Expr3>;
    (e.Pars1 (assign (weval e.data) e.asg)e.Pars2) e.Expr1 (weval e.data) e.Expr2 = 
        <GenerateNewParameters (e.Pars1 (assign (weval e.data) e.asg)e.Pars2) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr1 (weval e t.name) e.Expr2 =
        <GenerateNewParameters (e.Pars (assign (weval e t.name)((par e <FreshIndex 'pare_ind'>)))) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr1 (weval t t.name) e.Expr2 =
        <GenerateNewParameters (e.Pars (assign (weval t t.name)((par t <FreshIndex 'part_ind'>)))) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr1 (weval s t.name) e.Expr2 =
        <GenerateNewParameters (e.Pars (assign (weval s t.name)((par s <FreshIndex 'pars_ind'>)))) e.Expr1 e.Expr2>;
    (e.Pars) e.Expr = e.Pars;
}

/*
   $ENTRY SolveWEforEB {
    t.EquationBlock, 
    <GetMarkedEquation ('D') t.EquationBlock> : (AreEqual ('D')(e.MS1)(e.OldLHS)(e.MS2)(e.OldRHS)),
    <GenerateNewParameters ()e.OldLHS e.OldRHS> : e.Subst,
    <Substitute (e.Subst)e.OldLHS> : e.LHS,
    <Substitute (e.Subst)e.OldRHS> : e.RHS,
    (call SAT (args (arg 
        (call 
            <ExtractPseudoFunction 
                (e.LHS)(e.RHS)()()()()
            > 
        (args (arg ('*' e.LHS)('*' e.RHS))))))) : t.EquationCall,
    <Substitute (e.Subst)<ExtractRelevantNumeric t.EquationBlock (e.MS1 e.MS2)>> : e.Numeric,
    <SubstituteInGrammar (e.Subst)<ExtractRelevantGrammars t.EquationBlock (e.MS1 e.MS2)>> : e.Grammar,
    <FormatStack 
        <YieldDecomposition 
            (((assign (var l (0)) 
                (<AssignTimeStamps t.EquationCall>))))
        >
    > : (e.Config)(e.Stack)
    = <RestartIndices 'pare_ind'><RestartIndices 'part_ind'><RestartIndices 'pars_ind'>
    <UnfoldMain (EqualitySolving) 
        <PutEBtoNode 
            <GenerateNewNode (0)>
                    <ReplaceEBGrammars
                    <ReplaceEBNumericEqs <GenerateNewEB> e.Numeric>
                    e.Grammar
                    >
            >
        ((0))
        (Node Undriven (0) ())
    >;
   } 
*/


PutEBtoNode {
    t.EquationBlock t.Node = t.EquationBlock t.Node;        
}

/* конец подготовительных функций */

ExtractInfoQWE {
	t.Numeric (AreEqual (s.Log1)(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS)),
        <MyIfNotLess 
            <MyInc <MyOne>>
            <MaxElementPowerMS (<SubtractEl (Inf Const)(<MergeSets (e.ParMS1)(e.ParMS2)>)>)>
        > : 
        {'T',
        <DecideQWESolvability t.Numeric(AreEqual (s.Log1)(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS))> :
            {'T' 
                = 
                (Grammar )
                (Numeric )
                (Common ()(<PlaceInCommEqs (AreEqual ('F')(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS))(New)(Generic)>)('T'))
                (Variants );
            'F' 
                = <Putout 1 'No solutions of equation'><Putout 1 (AreEqual (e.LHS)(e.RHS))>
                (Grammar )
                (Numeric )
                (Common ()((New)(Generic))('F'))
                (Variants );
            };
        'F' 
            =   
            (Grammar )
            (Numeric )
            (Common ()(<PlaceInCommEqs (AreEqual ('F')(e.ParMS1)(e.LHS)(e.ParMS2)(e.RHS))(New)(Generic)>)('T'))
            (Variants );
        };
}

$ENTRY IterateSWEforEB {
/*
    t.EquationBlock, 
    <GetMarkedEquation ('D') t.EquationBlock> : t.Equation,
        <DeleteEBEquation t.EquationBlock t.Equation> : t.EqBlock1,
        <GetEBNumericForSingleEq t.EqBlock1 t.Equation> : e.Numeric,
        <GetEBGrammarForSingleEq t.EqBlock1 t.Equation> : e.Grammar        =
            <IterateSWEforEB 
                <PostProcessSWE 
                    t.EqBlock1 
                    <>
                    t.Equation
                >>; 
*/
    t.EquationBlock = t.EquationBlock;
} 

Normalize4Split {
    (AreEqual (s.Log)t.MS1(e.LHS)t.MS2 (e.RHS)) = (AreEqual (e.LHS)(e.RHS));
    (AreEqual (s.Log)(e.LHS)(e.RHS)) = (AreEqual (e.LHS)(e.RHS)); 
}

PostProcessSWE {
    t.EquationBlock 'F' t.Equation = <MakeEBContr>;
    t.EquationBlock 'T' (AreEqual (s.Log)e.OtherData)
        = <AddEBNewEqs t.EquationBlock (AreEqual ('F')e.OtherData)>;
}

/* Последовательная обработка текущего блока уравнений без попыток решения их. */
$ENTRY IterateWEforPRTCs {
	t.EquationBlock e.Other, <IsContradictory t.EquationBlock> : 'T',
        e.Other :
        {       = <MakeEBContr>;
            e.NonEmpty  = <IterateWEforPRTCs e.NonEmpty>;
        };
        t.EquationBlock e.Other, <GetEBState t.EquationBlock> : 'T'
            = <IterateWEforPRTCs <DeleteDoubleEqs t.EquationBlock>>;
/* 2. Пока имеются новые уравнения, не расщепленные - осуществляем расщепление. */
	t.EquationBlock e.Other,
        <GetMarkedEquation ('T') t.EquationBlock> : t.Equation,
        <GetEBNumericEqs t.EquationBlock> : e.Numeric,
        <Br 'EquationType=1'> : e.x  
            = <Putout 1 'Splitting...'><Putout 1 t.Equation><IterateWEforPRTCs
            <NormalizeEB            
                <IntegrateEqSolResults (Grammar )(Numeric ) 
                    <SplitEquation (e.Numeric)
                        <Normalize4Split t.Equation>
                    > 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                > 
                >
                e.Other
            >;
/*
   3. Нерасщепленных новых уравнений не осталось, но есть не оцененные числовыми равенствами -
   оцениваем их. 
*/

	t.EquationBlock e.Other,
        <GetMarkedEquation ('N') t.EquationBlock> : t.Equation,
        <Br 'EquationType=1'> : e.x        
            = <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults (Grammar )
                    <NumericEsteem t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
            >;
/* 4. Пока имеются общие уравнения, не расщепленные - осуществляем расщепление. */
	t.EquationBlock e.Other,
        <GetMarkedGenericEquation ('T') t.EquationBlock> : t.Equation,
        <GetEBNumericEqs t.EquationBlock> : e.Numeric,
        <Br 'EquationType=0'> : e.x 
        =
            <Putout 1 'Splitting...'><Putout 1 t.Equation><IterateWEforPRTCs
            <NormalizeEB            
                <IntegrateEqSolResults (Grammar )(Numeric ) 
                    <SplitEquation (e.Numeric)
                        <Normalize4Split t.Equation>
                    > 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                > 
                >
                e.Other
            >;
/*
   5. Нерасщепленных общих уравнений не осталось, но есть не оцененные числовыми равенствами -
   оцениваем их. 
*/

	t.EquationBlock e.Other,
        <GetMarkedGenericEquation ('N') t.EquationBlock> : t.Equation,
        <Br 'EquationType=0'> : e.x
            = <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults (Grammar )
                    <NumericEsteem t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
            >;
/* 6. Остались не проверенные на разрешимость новые уравнения - проверяем их. */
	t.EquationBlock e.Other,
        <CurrentIndex 'SolveEqMode'> : '0',
        <GetMarkedEquation ('D') t.EquationBlock> : t.Equation,
        <Br 'EquationType=1'> : e.x 
            = <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults <ExtractInfoQWE (<GetEBNumericEqs t.EquationBlock>) t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
            >;
/* 7. Остались не проверенные на разрешимость общие уравнения - проверяем их. */
    t.EquationBlock e.Other,
    <CurrentIndex 'SolveEqMode'> : '0',
    <GetMarkedGenericEquation ('D') t.EquationBlock> : t.Equation,
    <Br 'EquationType=0'> : e.x 
        =
        <IterateWEforPRTCs 
                <NormalizeEB
                <IntegrateEqSolResults <ExtractInfoQWE (<GetEBNumericEqs t.EquationBlock>) t.Equation> 
                    <DeleteEBEquation t.EquationBlock t.Equation>
                >
                >
                e.Other 
        >;
/*
   8. Все общие уравнения для данной конфигурации разобраны, но остались варианты - расщепляем блок
   уравнений по вариантам. 
*/

    t.EquationBlock e.Other,
    <GetFirstVariants t.EquationBlock> : t.EqBlock1 (e.Cases)e.Rest,
    e.Cases : t.1 e.1
        =
        <IterateWEforPRTCs <GenerateEBlocks t.EqBlock1 e.Cases>>;
            
    t.EquationBlock = t.EquationBlock;
    
    t.EquationBlock e.Other = t.EquationBlock <IterateWEforPRTCs e.Other>;
}

GenerateEBlocks {
    t.EquationBlock = ;
    t.EquationBlock (Case (e.Asgs)(e.Eqs)(s.Log)) e.Other 
        =
        <NormalizeEB <SubstituteEBAsgs <AddEBNewEqs t.EquationBlock e.Eqs>(e.Asgs)>>
        <GenerateEBlocks t.EquationBlock e.Other>;
}

GetMarkedGenericEquation {
    (s.Log) t.EquationBlock, 
    <GetEBGenEqs t.EquationBlock> : e.1 (AreEqual (s.Log) e.Data) e.2
        = (AreEqual (s.Log)e.Data);
    (s.Log) t.EquationBlock = ;
}

GetMarkedEquation {
    (s.Log) t.EquationBlock, 
    <GetEBNewEqs t.EquationBlock> : e.1 (AreEqual (s.Log) e.Data) e.2
        = (AreEqual (s.Log)e.Data);
    (s.Log) t.EquationBlock = ;
}

$ENTRY IntegrateEqSolResults {
    (Grammar e.1)(Numeric e.2)
         (Common (e.Assignments)(e.Equations)('F'))(Variants e.Vars) t.EquationBlock 
             = <MakeEBContr t.EquationBlock>;
    (Grammar )(Numeric )(Common ()((New)(Generic))(s.Log))(Variants ) t.EquationBlock = t.EquationBlock;
    (Grammar e.Grammar)(Numeric e.Numeric)(Common ()((New)(Generic))('T'))(Variants ) t.EquationBlock,
        <Putout 1 'New numeric:'>
        <Putout 1 e.Numeric>
        <SubstituteInNumeric 
                (<GeneratePseudoSubs e.Numeric>)
                <AddEBNumEqs t.EquationBlock e.Numeric>> : t.ModEqBlock,
        <MarkEquationsChanges 
            ()
            (e.Numeric)
            <GetEBNewEqs t.ModEqBlock>
            <GetEBGenEqs t.ModEqBlock>
        > : e.AsgsNew,
        <Putout 1 'New assignments are generated:'><Putout 1 e.AsgsNew>
        <SubstituteEBAsgs t.ModEqBlock (e.AsgsNew)> :
        {(e.EqBlock1('F')) = <Putout 1 'Assignments led to contradiction.'>
                        <MakeEBContr t.EquationBlock>;
        t.NewEqBlock = t.NewEqBlock;
            
        };
    (Grammar e.Grammar)(Numeric e.Numeric)
         (Common (e.Assignments)((New e.NewEqs)(Generic e.GenEqs))(s.Log))(Variants ) t.EquationBlock,
        <SubstituteEBAsgs <ReplaceEBNumericEqs <GenerateNewEB> e.Numeric> (e.Assignments)> :
        { (e.EqBlock ('F')) = <MakeEBContr t.EquationBlock>;
           t.NumEqBlock = 
               <Putout 1 'New common data:'>
               <Putout 1 e.Assignments e.NewEqs e.GenEqs> 
               <IntegrateEqSolResults
                   (Grammar e.Grammar)
                   (Numeric <GetEBNumericEqs t.NumEqBlock>)
                   (Common ()((New)(Generic))('T'))(Variants )
                   <SubstituteEBAsgs 
                   <AddEBGenEqs 
                       <AddEBNewEqs 
                           <PutEBState t.EquationBlock 'T'> 
                            e.NewEqs>
                       e.GenEqs
                    > (e.Assignments)>
                >;
        };
    (Grammar e.Grammar)(Numeric e.Numeric)(Common e.Common)(Variants e.Vars) t.EquationBlock,
    e.Vars : t.1 e.1 
         = 
        <Putout 1 'New variants:'><Putout 1 e.Vars><IntegrateEqSolResults 
            (Grammar e.Grammar)
            (Numeric e.Numeric)
            (Common e.Common)
            (Variants )
            <AddEBVariants 
                t.EquationBlock e.Vars
            >
        >;
}

GeneratePseudoSubs {
    = ;
    (AreEqual ((1 t.Element))(e.MS)) e.Other = (assign t.Element (e.MS)(Pseudo))<GeneratePseudoSubs e.Other>;
    (AreEqual e.Z) e.Other = <GeneratePseudoSubs e.Other>;
}

MarkEquationsChanges {
    (e.CandidateEqs)(e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
        e.Eqs1 (AreEqual e.EqData1 (t.var1 e.SomeExpr) e.EqData2) e.Eqs2
            = <MarkEquationsChanges 
                (e.CandidateEqs (AreEqual e.EqData1 (t.var1 e.SomeExpr) e.EqData2))
                (e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
                e.Eqs1 e.Eqs2>;
        
    (e.CandidateEqs)(e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
        e.Eqs1 (AreEqual e.EqData1 (e.SomeExpr t.var1) e.EqData2) e.Eqs2
            = <MarkEquationsChanges 
                (e.CandidateEqs (AreEqual e.EqData1 (e.SomeExpr t.var1) e.EqData2))
                (e.Num1 (AreEqual ((1 t.var1))(e.MSEq)) e.Num2)
                e.Eqs1 e.Eqs2>;

     (e.CandidateEqs)(e.Numeric)e.OtherEqs 
         = <FindSplittableEqs 
             (e.Numeric) 
             <AssignAllEndVars e.CandidateEqs>
            > e.OtherEqs;
}

AssignAllEndVars {
    = ;
    t.Eq e.Other = <AssignEndVars t.Eq><AssignAllEndVars e.Other>;
}

FindSplittableEqs {
    ()e.EqsRest = ;
    (e.Num) = ;
    (t.Num1 e.Num) e.MarkedEqs,
    <GetProcessableEndMarkEqs ()()()t.Num1 e.MarkedEqs> : (e.Assignments)(e.EqsRest)
        = e.Assignments <FindSplittableEqs (e.Num)e.EqsRest>;
}

GetConstPow {
    e.1 (s.Num Const) e.2 = s.Num;
    e.Z = 0;
}

GetProcessableEndMarkEqs {
    (e.Assignments)(e.Changeable)(e.Unchangeable)t.Num 
        = (e.Assignments)(e.Changeable e.Unchangeable); 
    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with ((0 Const) t.var1)((s.Num Const) t.var2))(Ends with (e.LHSE)(e.RHSE))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 0 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;

    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with (e.LHSB)(e.RHSB)(Ends with ((0 Const) t.var1)((s.Num Const) t.var2)))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 1 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;
            
    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with ((s.Num Const) t.var2)((0 Const) t.var1))(Ends with (e.LHSE)(e.RHSE))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 0 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;

    (e.Assignments)(e.Changeable)(e.Unchangeable)(AreEqual ((1 t.var1)(e.MSEq)))
        (t.Equation (Begins with (e.LHSB)(e.RHSB)(Ends with ((s.Num Const) t.var2)((0 Const) t.var1)))) e.RestEqs,
            e.MSEq : e.1 (s.PowVar2 t.var2) e.2,
            <MyIfNotLess <GetConstPow e.MSEq> s.Num> : 'T',
            <ConstructNewAssignment 0 t.var1 ((s.Num Const) t.var2)> : t.newasgnt
                = <GetProcessableEndMarkEqs 
                    (e.Assignments t.newasgnt)
                    (e.Changeable t.Equation)
                    (e.Unchangeable)
                    (AreEqual ((1 t.var1)(e.MSEq)))
                    e.RestEqs
                >;

    (e.Assignments)(e.Changeable)(e.Unchangeable)t.NumEq
    (t.Equation e.Data) e.RestEqs
        = <GetProcessableEndMarkEqs (e.Assignments)(e.Changeable)(e.Unchangeable t.Equation)t.NumEq e.RestEqs>;
}

ConstructNewAssignment {
    s.Mode (weval e t.name)((0 Const)(weval e t.name2)),
    <FreshIndex 'wevale_ind'> : t.newname 
        = (assign 
            (weval e t.name) 
            ((0 Const)(1 (weval e t.name2))(1 (weval e t.newname)))
            (<ShuffleMode s.Mode (weval e t.name2)(weval e t.newname)>)
            );
    s.Mode (weval e t.name)((s.Num Const)(weval e t.name2)),
    <FreshIndex 'wevale_ind'> : t.newname,
    <GenerateLengthRestriction (<MyZero>)()(weval e t.name)s.Num> : 
        (assign (weval e t.name)t.MS(e.Expr)) 
        = (assign 
            (weval e t.name) 
            ((s.Num Const)(1 (weval e t.name2))(1 (weval e t.newname)))
            (<ShuffleMode <Switch s.Mode>(weval e t.newname)<ShuffleMode <Switch s.Mode> (weval e t.name2) e.Expr>>)
            );
    s.Mode e.OtherData
        = <MSCPError ('Endmarked variables are not of expression type.')(e.OtherData)>;
}

Switch {
0 = 1;
1 = 0;
}

AssignEndVars {
    (AreEqual e.Eq) = ((AreEqual e.Eq)<AssignEndVars Started 0 (<MyZero>)(<MyZero>)(AreEqual e.Eq)>);
    Started 0 (s.NumL)(s.NumR)(AreEqual (s.Log) t.MS1(t.1 e.LHS)t.MS2(t.2 e.RHS)),
    <IsFreeVar t.1> :
    {'T',
    <IsFreeVar t.2> :
        {'T' 
            = (Begins with ((s.NumL Const) t.1) ((s.NumR Const)t.2))
            <AssignEndVars Started 1 (<MyZero>)(<MyZero>)(AreEqual (s.Log) t.MS1(t.1 e.LHS)t.MS2(t.2 e.RHS))>;
        'F' = <AssignEndVars Started 0 (s.NumL)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(t.1 e.LHS)t.MS2(e.RHS))>;
        };
     'F',
     <IsFreeVar t.2>:
        {'T' = <AssignEndVars Started 0 (<MyInc s.NumL>)(s.NumR)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2(t.2 e.RHS))>;
        'F' = <AssignEndVars Started 0 (<MyInc s.NumL>)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2(e.RHS))>;
        };
    };
    Started 1 (s.NumL)(s.NumR)(AreEqual (s.Log) t.MS1(e.LHS t.1)t.MS2(e.RHS t.2)),
    <IsFreeVar t.1> :
    {'T',
    <IsFreeVar t.2> :
        {'T' = (Ends with ((s.NumL Const) t.1) ((s.NumR Const)t.2));
        'F' = <AssignEndVars Started 1 (s.NumL)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(e.LHS t.1)t.MS2(e.RHS))>;
        };
     'F',
     <IsFreeVar t.2>:
        {'T' = <AssignEndVars Started 1 (<MyInc s.NumL>)(s.NumR)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2 (e.RHS t.2))>;
        'F' = <AssignEndVars Started 1 (<MyInc s.NumL>)(<MyInc s.NumR>)(AreEqual (s.Log) t.MS1(e.LHS)t.MS2(e.RHS))>;
        };
    };
    Started 0 (s.Num1)(s.Num2) e.Other 
        = (Begins with constants)(Ends with constants);
    Started 1 (s.Num1)(s.Num2) e.Other 
        = (Ends with constants);    
}

IsFreeVar {
    (weval e e.name) = 'T';
    t.other = 'F';
}

PostProcessSingleSplit {
    (Common (e.Asg1)(e.Eqs1)(s.Log1))(Variants (Case (e.Asg2)(e.Eqs2)(s.Log2)))
        = (Common (e.Asg1 e.Asg2)(e.Eqs1 e.Eqs2)(<LogAnd s.Log1 s.Log2>))(Variants );
    e.Z = e.Z;
}

PlaceInCommEqs {
    t.Equation (New e.NewEqs)(Generic e.GenEqs),
    <CurrentIndex 'SolveEqMode'> :
    { '1' = (New e.NewEqs t.Equation)(Generic e.GenEqs);
     '0',
     <CurrentIndex 'EquationType'> :
        { '0' = (New e.NewEqs)(Generic e.GenEqs t.Equation);
          '1' = (New e.NewEqs t.Equation)(Generic e.GenEqs);
        };
    };
}

PostProcessSplits {
    (Common e.1)(Variants e.2) = (Common e.1)(Variants e.2);
    e.1 (Common ()((New)(Generic))('T'))(Variants ) e.2 = e.1 e.2;
    (Common (e.Asg1)((New e.NewEqs1)(Generic e.GenEqs1))(s.Log1))(Variants e.Cases1)
    (Common (e.Asg2)((New e.NewEqs2)(Generic e.GenEqs2))(s.Log2))(Variants e.Cases2) e.Left 
        =
        <PostProcessSplits
            (Common (e.Asg1 e.Asg2)((New e.NewEqs1 e.NewEqs2)(Generic e.GenEqs1 e.GenEqs2))(<LogAnd s.Log1 s.Log2>))
            (Variants <MultiplyCases (e.Cases1) e.Cases2>)
            e.Left
        >;
}

MultiplyCases {
     = ;
    (e.Cases1) = e.Cases1;
    ()e.Cases2 = e.Cases2;
    ((Multiply e.Cases1)) e.Cases2 = (Multiply e.Cases1 (e.Cases2));
    (e.Cases1)(Multiply e.Cases2) = (Multiply (e.Cases1) e.Cases2);
    (e.Cases1)e.Cases2 = (Multiply (e.Cases1)(e.Cases2));
}

/*
    подготовительная функция для разделения уравнения на подуравнения
   Вход:
   (AreEqual ([WevalExpr]) ([WevalExpr]))
   результат:
   (Common (e.Assignments)([e.Equations])(s.Log))(Case (e.Assignments)([e.Equations])(s.Log))^*
   [e.Equations]::=(AreEqual ((s.Log1)(e.MS1)(e.LHS))((s.Log2)(e.MS2)(e.RHS)))^ 
*/

$ENTRY SplitEquation {
/* 1. C двух сторон одно и то же выражение - успешное завершение, уравнение пропадает (тождество). */
    (e.Numeric)(AreEqual t.1 t.1) = (Common ()((New)(Generic))('T'))(Variants ); 
/*
   2. C одной стороны ещё остались элементы уравнения, а с другой уже нет - переходим
   к подсчету мультимножеств элементов уравнения. 
*/
    (e.Numeric)(AreEqual ()(e.2)) = <SplitEquationLeft (e.Numeric) 0 (AreEqual ((<MyZero> Const))()()((<MyZero> Const))()(e.2))>; 
    (e.Numeric)(AreEqual (e.1)()) = <SplitEquationLeft (e.Numeric) 0 (AreEqual ((<MyZero> Const))()(e.1)((<MyZero> Const))()())>; 
/* 3. Отщепление равных термов слева и справа. */
    (e.Numeric)(AreEqual (e.1 t.1)(e.2 t.1)) = <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>;
    (e.Numeric)(AreEqual (t.1 e.1)(t.1 e.2)) = <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>;
/* 4. Отщепление скобок слева и справа. */
    (e.Numeric)(AreEqual (('*'e.01) e.1)(('*'e.02) e.2))
        = 
        <PostProcessSplits 
            (Common ()(<PlaceInCommEqs (AreEqual ('T')(e.01)(e.02))(New)(Generic)>)('T'))(Variants ) 
            <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>
        >;
    (e.Numeric)(AreEqual (e.1('*'e.01))(e.2('*'e.02))) 
        = 
        <PostProcessSplits 
            (Common ()(<PlaceInCommEqs (AreEqual ('T')(e.01)(e.02))(New)(Generic)>)('T'))(Variants ) 
            <SplitEquation (e.Numeric)(AreEqual (e.1)(e.2))>
        >;
    (e.Numeric)(AreEqual ((weval e t.Name1) e.LHS)((weval e t.Name2) e.RHS)),
    <InvolvedInNumeric 1(weval e t.Name1)(weval e t.Name2)(e.Numeric)> : t.NewAssignment,
    <Substitute (t.NewAssignment)(weval e t.Name1) e.LHS> : e.NewLHS,
    <Substitute (t.NewAssignment)(weval e t.Name2) e.RHS> : e.NewRHS
        =
        (Common 
            (t.NewAssignment)
            (<PlaceInCommEqs (AreEqual ('T')(e.NewLHS)(e.NewRHS))(New)(Generic)>)
            ('T')
        )
        (Variants );
    (e.Numeric)(AreEqual (e.LHS (weval e t.Name1))(e.RHS (weval e t.Name2))),
    <InvolvedInNumeric 0(weval e t.Name1)(weval e t.Name2)(e.Numeric)> : t.NewAssignment,
    <Substitute (t.NewAssignment) e.LHS (weval e t.Name1)> : e.NewLHS,
    <Substitute (t.NewAssignment) e.RHS (weval e t.Name2)> : e.NewRHS
        =
        (Common 
            (t.NewAssignment)
            (<PlaceInCommEqs (AreEqual ('T')(e.NewLHS)(e.NewRHS))(New)(Generic)>)
            ('T')
        )
        (Variants );
/* 5. С двух сторон переменные равных типов (но не е-типа) - они равны между собой. */
    (e.Numeric)(AreEqual ((weval t.type e.name1) e.1)((weval t.type e.name2) e.2)),
    <MSType (weval t.type e.name1)> : Const,
    (assign (weval t.type e.name1)((<MyOne> Const))((weval t.type e.name2))) : t.NewAssignment
        = 
        <PostProcessSplits 
            (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))
            >
        >;
    (e.Numeric)(AreEqual (e.1 (weval t.type e.name1))(e.2 (weval t.type e.name2))),
    <MSType (weval t.type e.name1)> : Const,
    (assign (weval t.type e.name1)((<MyOne> Const))((weval t.type e.name2))) : t.NewAssignment
        = 
        <PostProcessSplits 
            (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))
            >
        >;
/* 6. С одной стороны элемент уравнения более общего типа, чем с другой - формируем его уточнение. */
    (e.Numeric)(AreEqual (t.1 e.1)(t.2 e.2)),
    <LessGenericPattern t.1 t.2> : 'T',
    <MSType t.1> : Const,
    <TermContradiction t.2 t.1> : 'F',
    (assign t.1 ((<MyOne> Const))(t.2)) : t.NewAssignment 
        = 
        <PostProcessSplits 
            (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))
            >>;
    (e.Numeric)(AreEqual (t.1 e.1)(t.2 e.2)),
    <LessGenericPattern t.2 t.1> : 'T',
    <MSType t.2> : Const,
    <TermContradiction t.1 t.2> : 'F',
    (assign t.2 ((<MyOne> Const))(t.1)) : t.NewAssignment 
        = 
        <PostProcessSplits (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))>
        >;
    (e.Numeric)(AreEqual (e.1 t.1)(e.2 t.2)),
    <LessGenericPattern t.1 t.2> : 'T',
    <MSType t.1> : Const,
    <TermContradiction t.2 t.1> : 'F',
    (assign t.1 ((<MyOne> Const))(t.2)) : t.NewAssignment 
        = 
        <PostProcessSplits (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation 
                (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))>
        >;
    (e.Numeric)(AreEqual (e.1 t.1)(e.2 t.2)),
    <LessGenericPattern t.2 t.1> : 'T',
    <MSType t.2> : Const,
    <TermContradiction t.1 t.2> : 'F',
    (assign t.2 ((<MyOne> Const))(t.1)) : t.NewAssignment
        = 
        <PostProcessSplits (Common (t.NewAssignment)((New)(Generic))('T'))(Variants )
            <SplitEquation (e.Numeric)
                (AreEqual (<Substitute (t.NewAssignment)e.1>)(<Substitute (t.NewAssignment)e.2>))>
        >;
				
/* 7. Находим е-переменную (с одной или двух сторон), переходим к подсчету элементов уравнения. */
    (e.Numeric)(AreEqual ((weval e e.index1) e.1)((weval e e.index2) e.2))
        = 
        <SplitEquationLeft (e.Numeric)
            0 
            (AreEqual 
                ((<MyZero> Const)(<MyOne> (weval e e.index1)))
                ((weval e e.index1))
                (e.1)
                ((<MyZero> Const)(<MyOne> (weval e e.index2)))
                ((weval e e.index2))
                (e.2)
            )
        >;
    (e.Numeric)(AreEqual ((weval e e.index1) e.1)(t.2 e.2)) 
        = 
        <SplitEquationLeft (e.Numeric)
            0 
            (AreEqual 
                ((<MyZero> Const)(<MyOne> (weval e e.index1)))
                ((weval e e.index1))
                (e.1)
                ((<MyOne> Const))
                (t.2)
                (e.2)
            )
        >;
    (e.Numeric)(AreEqual (t.1 e.1)((weval e e.index2) e.2)) 
        = 
        <SplitEquationLeft (e.Numeric)
            0 
            (AreEqual 
                ((<MyOne> Const))
                (t.1)
                (e.1)
                ((<MyZero> Const)(<MyOne> (weval e e.index2)))
                ((weval e e.index2))
                (e.2)
            )
        >;
/* 8. Ни с одной стороны не переменная, не элемент более общего типа и не равные термы - противоречие. */
	(e.Numeric)(AreEqual (t.1 e.1)(e.2)) = (Common ()((New)(Generic))('F'))(Variants );
	(e.Numeric)(AreEqual (e.1)(t.2 e.2)) = (Common ()((New)(Generic))('F'))(Variants );
}/* SplitEquation */

/*
    Даны две переменные, обе стоят в начале (s.Mode=1) либо в конце (s.Mode=0) двух частей равенства.
   Если в численном блоке есть уравнение для длины одной переменной, включающее длину другой переменной,
   порождаем назначение, связывающее две эти переменные.
*/
InvolvedInNumeric {
    s.Mode t.Term1 t.Term2 (e.Num1 (AreEqual ((1 t.Term1))(e.MS1 (t.Pow t.Term2) e.MS2)) e.Num2),
    <FreshIndex 'wevale_ind'> : t.NewName
            = (assign t.Term1 ((<MyOne> t.Term2)(<MyOne> (weval e t.NewName)))
                (<InverseShuffle s.Mode t.Term2 (weval e t.NewName)>));
    s.Mode t.Term1 t.Term2 (e.Num1 (AreEqual ((1 t.Term2))(e.MS1 (t.Pow t.Term1) e.MS2)) e.Num2),
    <FreshIndex 'wevale_ind'> : t.NewName
            = (assign t.Term2 ((<MyOne> t.Term1)(<MyOne> (weval e t.NewName)))
                (<InverseShuffle s.Mode t.Term1 (weval e t.NewName)>));
    s.Mode t.Term1 t.Term2 (e.OtherNumeric) = ;
}

MSType {
    (weval e e.weval) = (weval e e.weval);
    (par e e.par) = (par e e.par);
    e.1 = Const;
}

ExtractTerm {
    0 t.1 e.1 = t.1;
    1 e.1 t.1 = t.1;
    s.Mode = ;
}

DeleteTerm {
    0 t.1 e.1 = e.1;
    1 e.1 t.1 = e.1;
    s.Mode = ;
}
InverseShuffle {
    0 t.1 e.1 = e.1 t.1;
    1 t.1 e.1 = t.1 e.1;
}

NonEmpty {
    ((0 Const)) = 'F';
    (e.Z) = 'T';
}

SplitEquationLeft {
/* 1. Оба выражения исчерпаны при разборе справа (т.е. окончательном). */
/* а) С одной стороны - лишь одна переменная, причем ее нет с другой стороны => возвращаем назначение. */
    (e.Numeric) 1 (AreEqual (e.ParMS1)((weval e e.var))()(e.ParMS2)(e.Proc2)()), 
    <TermContradiction (weval e e.var) e.Proc2> : 'F'
        = (Common ((assign (weval e e.var)(e.ParMS2)(e.Proc2)))((New)(Generic))('T'))(Variants );
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)()(e.ParMS2)((weval e e.var))()),
    <TermContradiction (weval e e.var) e.Proc1> : 'F'
        = (Common ((assign (weval e e.var)(e.ParMS1)(e.Proc1)))((New)(Generic))('T'))(Variants );
/*
   1б) Общий случай (включая случай, когда с одной стороны одна переменная, а с другой - выражение, включающее
   эту переменную). Уравнение считается расщепленным и готовым к оценке по длинам. 
*/
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)()(e.ParMS2)(e.Proc2)()) 
        = (Common ()(<PlaceInCommEqs (AreEqual ('N')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('N'))(Variants );
        
/*
   2. Мультимножества уже обработанных параметров слева и справа одинаковы - 
   оба уравнения обрабатываются отдельно друг от друга. 
*/
    (e.Numeric) s.Mode (AreEqual (e.ParMS1)(e.Proc1)(e.1)(e.ParMS2)(e.Proc2)(e.2)),
    <CompareMultiSets (e.ParMS1)(e.ParMS2)> : 'T',
    <NonEmpty (e.ParMS1)> : 'T' 
        =    
        <PostProcessSplits (Common ()(<PlaceInCommEqs (AreEqual ('N')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants )
				<SplitEquation (e.Numeric) (AreEqual (e.1)(e.2))>
        >; 
/* 3. С одной стороны еще остались термы, с другой нет, проход справа. Включаем терм в мультимножество параметров. */
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)(e.1 t.1)(e.ParMS2)(e.Proc2)()) 
        = 
        <SplitEquationLeft (e.Numeric) 
            1 
            (AreEqual 
                (<InsertInMultiSet 1(e.ParMS1)(<MyOne> <MSType t.1>)>)
                (t.1 e.Proc1)
                (e.1)
                (e.ParMS2)
                (e.Proc2)
                ()
            )
        >;
    (e.Numeric) 1 (AreEqual (e.ParMS1)(e.Proc1)()(e.ParMS2)(e.Proc2)(e.2 t.2)) 
        = 
        <SplitEquationLeft (e.Numeric)
            1 
            (AreEqual 
                (e.ParMS1)
                (e.Proc1)
                ()
                (<InsertInMultiSet 1(e.ParMS2)(<MyOne> <MSType t.2>)>)
                (t.2 e.Proc2)
                (e.2)
            )
        >;
/* 4. С двух сторон имеется по терму - помещаем их в мультимножества элементов уравнения. */
    (e.Numeric) s.Mode (AreEqual (e.OldParMS1)(e.Proc1)(e.1)(e.OldParMS2)(e.Proc2)(e.2)),
    <ExtractTerm s.Mode e.1> : t.1,
    <ExtractTerm s.Mode e.2> : t.2,
    <InsertInMultiSet s.Mode (e.OldParMS1)(<MyOne> <MSType t.1>)> : e.ParMS1,
    <InsertInMultiSet s.Mode (e.OldParMS2)(<MyOne> <MSType t.2>)> : e.ParMS2
        = 
        <SplitEquationLeft (e.Numeric) s.Mode 
            (AreEqual 
                (e.ParMS1)
                (<InverseShuffle s.Mode t.1 e.Proc1>)
                (<DeleteTerm s.Mode e.1>)
                (e.ParMS2)
                (<InverseShuffle s.Mode t.2 e.Proc2>)
                (<DeleteTerm s.Mode e.2>)
            )
        >;
/* 5. Разбор слева, хотя бы с одной стороны термов не осталось. Переход на разбор справа. */
    (e.Numeric) 0 (AreEqual (e.ParMS1)(e.Proc1)(e.1)(e.ParMS2)(e.Proc2)(e.2))
        =
        <SplitEquationLeft (e.Numeric) 1 (AreEqual ((<MyZero> Const))()(e.Proc1 e.1)((<MyZero> Const))()(e.Proc2 e.2))>;
}/* SplitEquationLeft */

$ENTRY NumericEsteem {
    (AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
                = <NumericEstimation Standart
				(<SubtractMS (e.ParMS1)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
				(<SubtractMS (e.ParMS2)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
				(AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
                >;
    (AreEqual e.Log(e.ParMS1)(e.ParMS2)) 
                = <NumericEstimation Length 
				(<SubtractMS (e.ParMS1)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
				(<SubtractMS (e.ParMS2)(<FindMSIntersection (e.ParMS1)(e.ParMS2)>)>)
                                (AreEqual e.Log(e.ParMS1)(e.ParMS2))
                >;
}

NumericEstimation {
/* 1. Константы сопоставляются пустому выражению => противоречие. */
	s.Mode ((s.Pow Const)e.LSE)() t.Equation
            = (Numeric )(Common ()((New)(Generic))('F'))(Variants );
	s.Mode ()((s.Pow Const)e.RSE) t.Equation
            = (Numeric )(Common ()((New)(Generic))('F'))(Variants );
/* 2. Переменные сопоставляются пустому выражению => все они пусты. */
	s.Mode ()()t.Equation,
        s.Mode :
        {Standart,
        t.Equation : (AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
            = (Numeric )
                (Common 
                    ()
                    (<PlaceInCommEqs (AreEqual ('D')t.MS1 t.LHS t.MS2 t.RHS)(New)(Generic)>)
                    ('T'))
                (Variants );
        Length
            =   (Numeric )
                (Common 
                    ()((New)(Generic))
                    ('T'))
                (Variants );
        };
        s.Mode (e.LSE)()t.Equation,
        s.Mode : 
            {Standart,
            t.Equation : (AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
                = <AssignNil ()(e.LSE)(AreEqual t.MS1 t.LHS t.MS2 t.RHS)>;
            Length
                = <AssignNil ()(e.LSE)(AreEqual ((0 Const))()((0 Const))())>;
            };
        s.Mode ()(e.RSE)t.Equation,
        s.Mode : 
            {Standart,
            t.Equation : (AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
                = <AssignNil ()(e.RSE)(AreEqual t.MS1 t.LHS t.MS2 t.RHS)>;
            Length
                = <AssignNil ()(e.RSE)(AreEqual ((0 Const))()((0 Const))())>;
            };
/* 3. Имеется линейное диофантово уравнение на длины переменных => разрешаем его и возвращаем список назначений */
	s.Mode (e.LSE)((s.Pow Const)) t.Equation,
        s.Mode :
            {Standart
                = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.LSE)((s.Pow Const)))>
                        (t.Equation)>;
            Length
                = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.LSE)((s.Pow Const)))>
                        ((AreEqual ((0 Const))()((0 Const))()))>;
            };
        s.Mode ((s.Pow Const))(e.RSE) t.Equation,
        s.Mode :
            {Standart
                = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.RSE)((s.Pow Const)))>
                        (t.Equation)>;
            Length
                = <FormatAfterDE <SolveLinearDE ('T')(AreEqual (e.RSE)((s.Pow Const)))>
                        ((AreEqual ((0 Const))()((0 Const))()))>;
            };
/* 4. Общий делитель симметрической разности неконстантных элементов уравнения не делится на общий делитель разности констант - противоречие. */
        s.Mode (e.LSE)(e.RSE)
            (AreEqual e.Log
                (e.ParMS11 (s.Pow1 Const) e.ParMS12)e.LHS
                (e.ParMS21 (s.Pow2 Const) e.ParMS22)e.RHS),
            <SolveLinearDE 
                ('F')
                    (AreEqual 
                        (<SymSubstMS (e.ParMS11 e.ParMS12)(e.ParMS21 e.ParMS22)>)
                        (<SymSubstMS ((s.Pow1 Const))((s.Pow2 Const))>))
            > : ()('F')
            = (Numeric )(Common ()((New)(Generic))('F'))(Variants );

/*
    5. Слева или справа в мультимножествах разностей - только один элемент (его не может быть с другой стороны). 
   Извлекаем из данного соотношения уравнение на длину этого элемента. 
*/

        s.Mode ((t.Power (weval e t.Name)))(e.RSE)(AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
                = (Numeric <NormalizeNumericEquation (AreEqual (e.RSE)((t.Power (weval e t.Name))))>)
                  (Common ()(<PlaceInCommEqs (AreEqual ('D')t.MS1 t.LHS t.MS2 t.RHS)(New)(Generic)>)('T'))
                  (Variants );
        s.Mode (e.LSE)((t.Power (weval e t.Name)))(AreEqual e.Log t.MS1 t.LHS t.MS2 t.RHS)
                = (Numeric <NormalizeNumericEquation (AreEqual (e.LSE)((t.Power (weval e t.Name))))>)
                  (Common ()(<PlaceInCommEqs (AreEqual ('D')t.MS1 t.LHS t.MS2 t.RHS)(New)(Generic)>)('T'))
                  (Variants );
/* 6. Во всех прочих случаях возвращаем уравнение как есть. */
	s.Mode (e.LSE)(e.RSE) t.Equation,
        s.Mode :
            {Standart,
            t.Equation : (AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
                = (Numeric )(Common ()(<PlaceInCommEqs (AreEqual ('D')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants );
            Length
                = (Numeric t.Equation)(Common ()((New)(Generic))('T'))(Variants );
            };
}

/*
    Заменяем все вхождения переменных, равных пустому слову, в две части уравнения, на пустое слово. 
   Удаляем эти переменные из мультимножеств-индикаторов, добавляем назначения вида "переменная равна пустому слову". 
*/

AssignNil {
	(e.Assignments)()(AreEqual (e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
                = (Numeric )(Common (e.Assignments)(<PlaceInCommEqs (AreEqual ('T')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants );
	(e.Assignments)((t.Power (weval e e.index)) e.other)(AreEqual (e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))
                = <AssignNil (e.Assignments (assign (weval e e.index) ((<MyZero> Const))()))(e.other)
                        (AreEqual 
                                (<SubtractEl (Inf (weval e e.index))(e.ParMS1)>)
                                (<Substitute ((assign (weval e e.index)((<MyZero> Const))())) e.Proc1>)
                                (<SubtractEl (Inf (weval e e.index))(e.ParMS2)>)
                                (<Substitute ((assign (weval e e.index)((<MyZero> Const))())) e.Proc2>)
                        )
                >;
}

/* После того как ЛДУ на длины уравнений решено, смотрим результат. */
FormatAfterDE {
/* У ЛДУ нет решений. */
    (e.WevalAsgmnts)('F')((AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))) 
        = 
        (Numeric )(Common ()((New)(Generic))('F'))(Variants );
/* Нашлось единственное решение ЛДУ. */
    ((Case e.WevalAsgmnt))('T')((AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2)))
        =
        (Numeric )(Common (e.WevalAsgmnt)(<PlaceInCommEqs (AreEqual ('T')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))(Variants );
/* У ЛДУ более одного решения. */
    (e.WevalAsgmnts)('N')((AreEqual e.Log(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2)))
        =
        (Numeric )
        (Common ()(<PlaceInCommEqs (AreEqual ('D')(e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2))(New)(Generic)>)('T'))
        (Variants <GenerateCases (e.WevalAsgmnts)()>);
}

GenerateCases {
    ()(e.Eqs) = ;
    ((Case e.asg) e.OtherCases)(e.Eqs) = (Case (e.asg)(e.Eqs)('T'))<GenerateCases (e.OtherCases)(e.Eqs)>;
}

$ENTRY PreserveIfImplied {
    t.Equation (e.GivenEqs),
    <AddPRTCGenericEqs <ReplacePRTCNewEqs <GenerateFreshPRTC ()()> t.Equation> e.GivenEqs> : t.NewPRTC
        = <CheckForNullNewEqs (t.Equation)
            <SolveEquations t.NewPRTC>
        >;
}

CheckForNullNewEqs {
    (t.Equation) t.PRTC,
    <GetPRTCNewEqs t.PRTC> : ,
    <GetPRTCRestrs t.PRTC> : 
            = t.Equation;
    e.Z = ;
}

/* Для трассировщика. */
AAA { = ;}
